---
layout: post
title:  프로그래머스- 포켓몬
date:   2021-05-26 15:01:35 +0300
image:  https://user-images.githubusercontent.com/77090941/119234172-69717180-bb67-11eb-8acc-f687aa97de80.jpg
tags:   Style
---
### 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하며, 총 포켓몬의 배열을 "N"이라고 했을 때 "N/2"마리를 선택하려 합니다. N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.

--- 

> 입출력 예
> 
|nums	| result|
|-------|------|
|[3,1,2,3]	 | 2|
|[3,3,3,2,2,4] |	3|
|[3,3,3,2,2,2] | 2|

> 처음엔 지문에 길어 복잡한 문제인 줄 알았지만 사실은 간단한 문제였다. 알고리즘을 풀때는 문과적 이해력과 이과적 계산력 상상력이 필요한듯 하다.
> 결국 종류에 따라 return 값이 결정된다. 만약 배열을 n/2 했을 때 배열이 길이가 종류의 수 보다 작으면 배열을, 종류의 수가 배열 보다 작으면 종류를 return 하면 된다. 만약 선택하는 방법의 경우의 수를 구하라고 했으면 더 어려웠을 것이다. 

```js
function solution(nums) {
    var answer = 0; // 변수에 0을 할당 숫자로 return 되야하기 때문
    let divide = nums.length/2 // 일단 가지고 갈 수 있는 포켓몬의 수는 n/2니까 num을 2로 나눈다.
    let type =[] // 빈 배열을 할당한다.
    nums.map(el =>{    // nums의 요소를 뽑아
      if(!type.includes(el)){ // type 배열에 요소가 있는 지 확인하고
        type.push(el) // 요소가 없으면 type 배열로 넣는다.
      }
    })
    if(type.length>divide){ //종류의 수가 많으면 예, 종류[1,2,3,4,5], 나눈 배열 [1,2,3,4] 종류가 많아 그냥 아무거나 골라도 됨
      answer = divide // 반으로 나눈 값을 answer에 할당한다.
    }else{
      answer = type.length // 그렇지 않으면 종류의 수를 할당한다. 예, 종류 [1,2,3], 나눈 배열 [1,2,3,3,2,1] 배열이 많아 선택의 경우는 똑같다.
    }
    return answer;
}
```
만약 여기서 종류에 따른 경우의 수를 구하라고 한다면 type.length-1 부터 0까지 더하는 반복문을 만들면 될 것 같다. 
그리고 원래 배열의 n/2하는 것 까지 하면 조금은 복잡해질 것이다.
