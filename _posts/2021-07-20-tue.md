---
layout: post
title:  다이나믹 프로그래밍 (DP)
date:   2021-07-20 15:01:35 +0300
image:  https://user-images.githubusercontent.com/77090941/119234172-69717180-bb67-11eb-8acc-f687aa97de80.jpg
tags:   Style
---
### 다이나믹 프로그래밍 (동적 계획법)
* link: https://urclass.codestates.com/codeproblem/82fc4c0b-6e2d-4e97-b1ca-c84721a4422f

- 다이나믹 프로그래밍은 동적 계획법이라고도 부른다. 
- 일반적인 자료구조에서 동적 할당의 동적은 "프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법"을 의미한다
- 반면 동적 계획법에서의 동적은 "별다른 의미가 없다."
- 동적 계획법은 다음의 조건을 만족할 때 사용할 수 있다.
1. 최적 부분 구조(optimal Substructure)
   - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
2. 중복되는 부분 문제(Overlapping Subproblem)
   - 동일한 작은 문제를 반복적으로 해결해야한다.

### 피보나치 수열
- 피보나치 수열은 1,1,2,3,5,8,13,21,34... 와 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산할 수 있다.

일반재귀를 이용한 피보나치 구현
```js
let fibo=(n)=>(n>2? fibo(n-2)+ fibo(n-1): 1)
```

다이나믹 프로그래밍을 이용한 피보나치 구현 
```js
let fibo =[0]
let fiboWithMemoization = (n)=>{
    if(n<3){
        fiboArr[n]=1
    }
    if(!fiboArr[n]){
        fiboArr[n] = fiboWithMemoization(n-1)+ fiboWithMemoization(n-2)
    }

    return fiboArr[n]
}
```
위의 dp를 이용한 피보나치구현을 보면 fiboArr 이라는 곳에 내가 계산해둔 피보나치 수를 저장해둔다. 이러한 방식의 차이는 속도면에서 어마어마한 차이를 가져온다.
이를테면 50번쨰 피보나치 수를 구하는 것은 메모이제이션을 사용하지 않는 단순 재기에서는 어마어마한 시간이 걸리지만, 메모이제이션을 사용한 피보나치 수 구하기 함수를 이용하면 금방 나온다

메모이제이션을 하지 않으면, 대략 O(2n^2) 만큼의 시간복잡도가 걸린다.
메모이제이션을 하면 대략 O(3n) 만큼의 시간에 값을 구하게 된다

### 다이나믹 프로그래밍의 구현 방식
1. Top-down 
 - 큰 문제부터 문제를 쪼개가며 작은 문제로 만들고 다시 합쳐가며 원래 문제를 푸는 방식

2. Bottom-up
 - 작은 문제들을 모아서 큰 문제를 만들어 쌓아 올려가는 방식

앞에서 봤던 재귀 방식은 Top-down 방식이라고 할 수 있음
Bottom-up은 주로 반복문을 사용해서 구현함

### Top-down 과 Bottom-up의 시간차
알 수 없다. 일단 재귀는 함수 호출 과정이 많이 들어가서 스택 오버플로우를 만들 수도 있고, 반복문이 더 빠를 것 같은데 알 수 없는 이유는 Bottom-up 방식은 정말 모든 문제를 풀고 Top-down 은 그렇지 않은 경우가 있기 때문이다.
