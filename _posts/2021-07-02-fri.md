---
layout: post
title:  프로그래머스 -가장 큰 수
date:   2021-07-02 15:01:35 +0300
image:  https://user-images.githubusercontent.com/77090941/119234172-69717180-bb67-11eb-8acc-f687aa97de80.jpg
tags:   Style
---
```js
// 배열이 주어지고 그 안의 요소들을 가장 큰 수 가 되게 조합하는 문제였습니다.
// 첫 문제를 쉽게 풀고 와서 그런지 더 어렵게 느껴지던 문제였습니다.
// 처음에는 그냥 sort를 했을 때 십의 자리수를 고려하직 않고 앞자리 숫자를 중심을로 정렬되는 걸 이용하려 했습니다.
// [1,4,6,11,23,34,45] ==>[1,11,23,34,4,43,6] 이런식으로 정렬 됐을 때 뒤에서 부터 붙여주면 어떻게 나올 것 같았는데
// 그렇게 되지 않는 것 같아 결국 인터넷에 찾아서 문자열로 바꿔서 비교하는 방법을 알았습니다.  

function solution(numbers) {

    var answer = '';  // 빈 문자열을 할당합니다.

    let second = numbers.map(el =>""+el+el+el) // 주어진 수의 배열 numbers에서 요소들을 문자로 바꾸고 세번 더 해줍니다.
                                                // 이런식으로 하면 [1,11,23,34,4,43,6] 
                                                // ==>['111','111111','232323','343434','444','434343','666']
                                                // 이렇게 하면 앞의 세번째 자릿 수 까지해서 비교를 할 수 있답니다.
                                                // 그러므로 '444' 와 '434343'은 '444'가 높게 취급을 받게 됩니다.
    let sorted = second.slice(0).sort((a,b)=>(a+b)-(b+a)) // 정열을 해줍니다. 
                                            //=> ['111','111111','232323','343434','434343','444','666']
    for(let i=second.length-1; i>=0; i--){ //뒤의 큰 수 부터 나오도록 반복문을 돌려줍니다.
        
        let idx = second.indexOf(sorted[i]) // 이때 요소를 결과 값이 될 answer에 넣어 줄 때 
                                    // 원 배열인 number의 인덱스를 따를 수 있도록 
                                    // 정열되기 전의 값인 second에 sorted 요소의 인덱스를 찾아주고
                                     
        answer+= numbers[idx]       // number의 인덱스에 적용시켜서 더해줍니다.
    }
    return answer[0]==='0'?"0": answer // 이것 때문에 시간이 좀 낭비됐는데, 왜 틀린지 모르고 있다가
                                    // 인터넷에서 찾아보고 알았습니다. 0이 배열에 여러번 들어갈 경우
                                    // '0000' 이런 식의 값이 만들어 지는데, 이때 "0"을 리턴해야 한다는 말이었습니다.
}