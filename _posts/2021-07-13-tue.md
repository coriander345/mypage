---
layout: post
title:  CSR& SSR
date:   2021-07-13 15:01:35 +0300
image:  https://user-images.githubusercontent.com/77090941/119234172-69717180-bb67-11eb-8acc-f687aa97de80.jpg
tags:   Style
---
### CSR(Client Side Rendering) & SSR(Server Side Rendering)
* link: https://tech.weperson.com/wedev/frontend/csr-ssr-spa-mpa-pwa/#csr-client-side-rendering-vs-ssr-server-side-rendering

랜더링 방식이란 화면에 나타나는 HTML을 누가 주최해서 하는 가에 따라 CSR과 SSR로 나뉩니다. 
이 개념이 대두되기 시작한 것은 자바스크립트 기반의 프레임워크들이 대세가 되면서 부터 입니다. (react, angular, vue)

다음은 JS 기반 웹 프레임워크들의 시작 index.html 입니다.
```html
<html>
    <head>
        <title>Title</title>
    </head>
    <body>
        <div id="app"></div>
    </body>
</html>   
```
body안에는 div 하나만 있습니다. 실제로 이 뼈대 하나만 다운받습니다. 우리가 화면을 볼때는 div안에 다양한 tag들이 존재하는데 이를 html파일과 함께 아운받은 js파일의 로직을 통해서 동적으로 테그나 스타일들을 DOM에 더하여 그리기 때문입니다. 
다음은 유저들이 보는 화면의 html입니다.
```html
<html>
    <head>
        <title>Title</title>
    </head>
    <body>
        <h1>Hello World!</h1>
        <p>이것이 최종적으로 화면에서 보고 있는 내용입니다.</p>
    </body>
</html>   
```
쉽게 말해 유저의 브라우저에서 서버에서 받은 파일들이 Dom 형식으로 그려지면 CSR이고 서버에서 그려져서 클라이언트에 보내지면 SSR입니다. 

- CSR
  
CSR은 단순합니다.  JS 프레임워크를 쓸 때, 각 프레임워크 문법에 맞게 코딩하고 빌드를 하게 되면 최종적으로 브라우저가 이해 할 수 이쓴ㄴ HTML, CSS, JS 형태의 파일이 아웃풋으로 나오게 되고 이때 웹서버는 아주 단순히 올려 놓은 파일을 전달해주는 전달자 역할만 합니다. 브라우저는 웹서버로 부터 다운받은 파일을 그냥 실행 할 뿐이고 JS 파일을 실행하면서 DOM에 내용을 추가하면서 그리게 됩니다.
초기에 JS를 읽어서 무엇을 그려야 할지를 판단하고 그리는 작업을 하는 동안 딜레이가 생기게 됩니다. 반면에 이후 작엽에 있어서는 서버의 의존도가 없이 클라이언트 혼자 그릴 수 있으므로 빠른 화면 전환이나 인터렉션(interaction)이 가능합니다. 

- SSR 
  
SSR은 HTML, CSS, JS를 직접 올리는 것이 아니라 해당 파일들을 만들어 낼 수 있는 로직을 올리고 서버에서 해당 로직을 실행해서 최종적으로 HTML, CSS, JS를 만들어 브라우저에 전달합니다. 만들어진 HTML파일에는 이미 DOM이 다구성이 되어 있습니다. 로직을 올린다는 것은 결국 실행 가능한 함수를 올리는 것이고 이는 백엔드 프레임워크에 해당 됩니다. 
이미 DOM이 다 구성된 파일을 브라우저가 받기 때문에 바로 그릴수가 있어서 초기 구동 속도가 빠릅니다. DOM에 이미 내용이 다 차있기 때문에 검색 엔진들이 정보를 수집할때 정확한 정보를 가져갈 수 있어서 SEO에 좋습니다. 

- CSR vs SSR

1. 초기구동: JS 기반 프레임워크는 CSR이든 SSR이든 주최가 다를뿐이지 js를 읽어서 DOM을 구성해야 합니다. 이때 서버는 다수를 상대함으로 서버 쪽에서 렌더링을 끝내고 보낸다면, 서버에 부담에 크고 유저의 브라우저에서 렌더링된다면 서버의 부담은 줄고 유저의 브라우저에서 렌더링이 늦어질 수 있습니다. 

2. CSR은 SEO에 취약하다!: CSR이 SEO(검색엔진 최적화-search engine Optimization)에 취약한것은 사실이나 그 전에 앞서 내 서비스 전체가 SEO가 필요한가를 고민해봐야 합니다. 모든 서비스가 다 SEO가 필요한 것이 아닙니다. 어떤 서비스는 고객의 데이터를 보호하기 위해 SEO가 핑요하지 않습니다. 

3. 비용문제: CSR로 구성할 경우 S3같은 단순 스토리지에 올리고 전면에 cloud front로 구성하여 캐싱과 레이터시를 줄이고 트레픽비용만 지불하게 됩니다. SSR의 경우 매번 서버에서 로직을 실행하는 비용을 추가하게 됩니다. 아까도 언급헸지만 동적 컨텐츠가 많은 경우 캐싱도 무효화됩니다. 인스턴스를 Auto Scale gkrjsk Serverless 기반에 Function을 사용하더라도 CSR과 비교해서 비용이 수천배 차이가 날 수도 있습니다. 

그러므로 뭐가 좋다고 단정적으로 말할 수는 없고 내가 어떤 프로젝트나 서비스를 구성할 지에 따라 맞는 방법을 사용해야 한다는 것입니다. 고객의 데이터를 보호해야 하는 경우나 비용이 민감할 겨우 CSR을 택할 수 있고, 정적 콘텐츠와 퍼블릭 데이터가 많은 경우에는 SSR을 선택하는 것이 좋고, 두 가지를 섞어서 서비스를 구성할 수도 있습니다.

- SPA(single page application) vs MPA(multi page application)
SPA 또한 JacaScript 기반 프레임워크들이 대중화 되면서 자주 언급된 용어입니다. 개념 자체가 단순하고 그 전 부터 있어 왔습니다. 글자 그대로 SPA는 하나의 페이지(single page)로 구성된 웹이고 MPA는 여러 개의 페이지(multi page)로 구성된 웹입니다.

기술적으로는 SPA는 어떤 페이지를 접속하더라도 HTM, CSS, JS 동일한 파일 하나만 접속한 페이지에 맞게 화면을 구성하고 MPA는 페이지 멸로 해당 페이지에 맞는 HTML, CSS, JS 파일을 받아서 화면을 구성합니다. 고전적인 방식이 MPA이며 아직도 많이 사용되어지고 있고, 최근 들어 JS 프레임워크들은 SPA를 기본으로 하고 있습니다. 

유저 입장으로 보았을 때는 단순히 페이지 내용이 확 바뀌고 브라우저상에 URL이 다르면 다른 페이지로 인식합니다. SPA의 트릭은 하나의 페이지에서 JS를 통하여 보고 있는 DOM의 내용을 모두 제거하고 다른 컨텐츠로 DOM을 채운 다음에 브라우저상에 URL을 강제로 변경하여, 실제로 방문한적도 없는 URL을 방문하여 해당 페이지를 보고 있는 느낌을 주는 것입니다. 

MPA는 일반적으로 하이퍼링크를 클릭했을 때 해당 페이지로 가고 화면이 한번 깜빡이면서 새로운 페이지가 로드되고 그때 해당 페이지에 맞는 HTML, CSS, JS를 받아 화면을 그리는 고전적인 방식입니다. 

- SPA, MPA 언제 무엇을 선택해야 하는가?

사실 SPA, MPA를 먼저 선택하기 보다는 사용하는 프레임워크나 아키텍처에 따라서 SPA, MPA가 정해진다는 표현이 더 맞은 것 같고, 개념상으로 이것이 어떻게 다른지를 이해하고 있어야 하는 것이 중요합니다. 

일반적으로 CSR=SPA, SSR=MPA 이라고 공식처럼 애기가 되는데 React, Vue, Angular 같은 JS 기반 프레임워크를 쓰면 기본적으로 HTML, CSS, JS 파일이 각 하나씩 나오기 때문에 자연그레 SPA가 되면서 CSR이 되는 것이고, 이를 SSR로 구현하면 페이지 별로 렌더링을 따로 하기 떄문에 MPA가 되는 것입니다. 참고로 현재 React, Vue, Angular 모두 SSR을 지원합니다.

MPA이면서 같은 JS파일을 받고 클라이언트에서 렌터링을 하게 되면 MPA+CSR이 되는 것이고 SPA면서 SSR을 택하면 SSR+SPA가 되는 것인데 원리를 이해라면 이런 식으로는 궁합이 잘 맞지 않기 떄문에 처음 언급한 공식처럼 사용이 되는 것입니다. 되고 안되고 보다는 무엇이 무엇인지를 이해하는 것이 중요합니다. 

필자의 개인적인 의견은 화면을 깜빡인다에 중점을 둠다고 한다. MPA는 페이지를 새로 로드하기 떄문에 화면 깜빡임 현상을 막을 수가 없습니다. SPA는 이미 로드한 페이지에서 DOM의 내용만 교체하기 때문에 이 깜빡임이 보이지 않습니다. 이 "한 번의 깜빡임"이라는 아주 작은 디테일 떄문에 아주 커다란 결과를 가져 올 수 있습니다. 

모바일의 경우는 트레픽과 빠른 인터렉션이 중요한데 이는 SPA와 잘 맞습니다. 초기 로딩은 살짝 느릴 수 있으나 모바일 브라우져도 결국은 자체적으로 캐싱을 하기 떄문에 이후에 네트워크 트레픽의 소모가 적고 이후 설명할 PWA를 활용하면 오프라인 상태에서도 인터렉션이 가능합니다. SPA는 깜빡임이 없기 떄문에 앞서 애기한 하이브리드 방식으로 앱을 개발하여 포장하여도 유저 입장에서 일반 앱과 차이를 느낄 수 없습니다. 하나의 서비스라 할지라도 PC웹은 SPA/PWA로 다른 형태의 패기징이 가능합니다.

> tip: 실제로 CSS, JS 파일은 Coding Spliting에 의해서 여러개로 나뉘어져 있고 SPA, MPA 상관 없이 Lazy Loading이 가능하나 해당 내용이 들어갈 경우 문맥이 너무 복잡해져서 파일 하나라고 표현했습니다. 문맥상 복잡한 내용은 앞으로도 단순화해서 표현할 예정이고 전체 흐름을 이해하는데는 이런식으로 설명하는 것이 더 도움이 됩니다. 

- PWA(Progressive Web App)

PWA란 프로그래시브 웹 앱이라고 하여 웹과 네이티브 앱의 기능을 모두 갖춘 형태입니다. 간단하게는 웹 처럼 URL로 접근하여 애플 스토어나 구글 스토어를 거치지 않고 모바일 디바이스 홈 화면에 바로 설치하여 사용이 가능하다는 것입니다. 설치하여 구동 시 상단에 URL 컨트롤을 감추어 일반적인 모바일 앱처럼 작동하게 만들 수도 있습니다. 궅이 설치를 하지 않더라도 모든 데이터를 기본적으로 캐싱하여 오프라인 상태에서도 데이터를 볼 수 있습니다. 





