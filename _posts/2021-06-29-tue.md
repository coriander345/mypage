---
layout: post
title:  플로이드 와샬 알고리즘
date:   2021-06-29 15:01:35 +0300
image:  https://user-images.githubusercontent.com/77090941/119234172-69717180-bb67-11eb-8acc-f687aa97de80.jpg
tags:   Style
---
* link: 안경잡이 개발자 블로그(blog.naver.com/ndb796)

### 플로이드 와샬 알고리즘 
모든 정점에서 모든 정점으로의 최단 경로를 구하고 싶을 때 사용합니다.
기본적으로 "거쳐가는 정점"을 기준으로 알고리즘을 수행한다는 점에서 그 특징이 있습니다.
> 변의 가중치가 음이거나 양인( 음수 사이클은 없는) 가중 그래프에서 최단 경로를 찾는 알고리즘이다. - 위키피디아-

```js
const INF = infinity

const floydWarchall = function(dist){
    const len = dist.length;
    for(let i=0; i<len; i++){
        for(let j=0; j<len; j++){
            for(let k=0; k<len; k++){
                if(dist[j][k]> dist[j][i] + dist[i][k]){
                    dist[j][k] = dist[j][i] + dist[i][k]
                }

            }
        }   
    }
}

const main = (function(){
    const graph = [
        [0,5,INF, 8],
        [7,0,9, INF],
        [2, INF, 0, 4],
        [INF, INF, 3,0]
    ];
    floydWarchall(graph);
    for(let i=0; i<graph.length; i++)
    console.log(graph[i])
},())
```
삼중 루프를 사용해서 시간복잡도는 O(N^3)이다.

||A|B|C|D| 
|---|---|---|---|---
A|0|5|INF|8
A|7|0|9|INF
C|2|INF|0|4
D|INF|INF|3|0

이러한 가중치를 가지는 그래프가 있다.
먼저 출발 정점을 A로 설정하고, 거쳐야할 정점을 A로 설정하겠다. A에 인접한 정점은 B,D이다. 따라서 현재 A의 경로는 다음과 같다. 

>A(시작 정점) ->A(중간정점)->B, 이동거리 5

>A(시작 정점) ->A(중간정점)->D, 이동거리 8

이번엔 출발 정점을 B로 설정하고, 거쳐야할 정점을 A로 설정하겠다. B에 인접한 정점은 A,C다. 따라서 현재 B의 경로는 다음과 같다. 

>B(시작 정점) ->A(중간정점)->A, 이동거리 7

>B(시작 정점) ->A(중간정점)->D, 이동거리 INF

이번엔 출발 정점을 C로 설정하고, 거쳐야할 정점을 A로 설정하겠다. C에 인접한 정점은 A,D다. 따라서 현재 C의 경로는 다음과 같다. 

>C(시작 정점) ->A(중간정점)->A, 이동거리 2

>C(시작 정점) ->A(중간정점)->D, 이동거리 10

여기서 C->A->D의 이동거리(10)보다 C-> D의 이동거리(4)가 더 작으므로, 값 변경은 없다.

이번엔 출발 정점을 D로 설정하고, 거쳐야할 정점을 A로 설정하겠다. D에 인접한 정점은 C다. 현재 D의 경로는 다음과 같다.

>D(시작 정점) ->A(중간정점)->C, 이동거리 INF

여기서 D->A->C 의 이동거리(무한)보다 D-> C의 이동거리(3)가 더 작으므로, 값 변경은 없다.
이렇게 거쳐야할 정점이 D가 될 때까지 반복하면 된다. 그리고 만들어진 경로와 기존의 경로를 비교해서 둘 중에 더 작은 값으로 업데이트하는 조건을 만들어 주면 된다. 이 조건을 다음과 같은 조건식으로 나타낼 수 있다. 

> d[시작정점][인접정점]> d[시작정점][거쳐야할 정점]+ d[인접정점][거쳐야할 정점]

